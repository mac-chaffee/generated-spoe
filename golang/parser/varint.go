// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

package parser

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * A variable-length unsigned integer using base128 encoding. 1-byte groups
 * consist of 1-byte flag of continuation and 7-bit value chunk, and are ordered
 * "most significant group first", i.e. in "big-endian" manner.
 * 
 * This particular encoding is specified and used in:
 * 
 * * Standard MIDI file format
 * * ASN.1 BER encoding
 * * RAR 5.0 file format
 * 
 * More information on this encoding is available at
 * https://en.wikipedia.org/wiki/Variable-length_quantity
 * 
 * This particular implementation supports serialized values to up 8 bytes long.
 */
type Varint struct {
	Groups []*Varint_Group
	_io *kaitai.Stream
	_root *Varint
	_parent interface{}
	_f_value bool
	value int
}
func NewVarint() *Varint {
	return &Varint{
	}
}

func (this *Varint) Read(io *kaitai.Stream, parent interface{}, root *Varint) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 1;; i++ {
		tmp2, err := this._io.Pos()
		if err != nil {
			return err
		}
		tmp1 := NewVarint_Group(tmp2)
		err = tmp1.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		_it := tmp1
		this.Groups = append(this.Groups, _it)
		tmp3, err := _it.HasNext()
		if err != nil {
			return err
		}
		if !(tmp3) {
			break
		}
	}
	return err
}

/**
 * Resulting value as normal integer
 */
func (this *Varint) Value() (v int, err error) {
	if (this._f_value) {
		return this.value, nil
	}
	tmp4, err := this.Groups[0].Value()
	if err != nil {
		return 0, err
	}
	var tmp5 int;
	if (len(this.Groups) >= 2) {
		tmp6, err := this.Groups[1].Value()
		if err != nil {
			return 0, err
		}
		tmp5 = (tmp6 << 4)
	} else {
		tmp5 = 0
	}
	var tmp7 int;
	if (len(this.Groups) >= 3) {
		tmp8, err := this.Groups[2].Value()
		if err != nil {
			return 0, err
		}
		tmp7 = (tmp8 << 11)
	} else {
		tmp7 = 0
	}
	var tmp9 int;
	if (len(this.Groups) >= 4) {
		tmp10, err := this.Groups[3].Value()
		if err != nil {
			return 0, err
		}
		tmp9 = (tmp10 << 18)
	} else {
		tmp9 = 0
	}
	var tmp11 int;
	if (len(this.Groups) >= 5) {
		tmp12, err := this.Groups[4].Value()
		if err != nil {
			return 0, err
		}
		tmp11 = (tmp12 << 25)
	} else {
		tmp11 = 0
	}
	var tmp13 int;
	if (len(this.Groups) >= 6) {
		tmp14, err := this.Groups[5].Value()
		if err != nil {
			return 0, err
		}
		tmp13 = (tmp14 << 32)
	} else {
		tmp13 = 0
	}
	var tmp15 int;
	if (len(this.Groups) >= 7) {
		tmp16, err := this.Groups[6].Value()
		if err != nil {
			return 0, err
		}
		tmp15 = (tmp16 << 39)
	} else {
		tmp15 = 0
	}
	var tmp17 int;
	if (len(this.Groups) >= 8) {
		tmp18, err := this.Groups[7].Value()
		if err != nil {
			return 0, err
		}
		tmp17 = (tmp18 << 46)
	} else {
		tmp17 = 0
	}
	this.value = int((((((((tmp4 + tmp5) + tmp7) + tmp9) + tmp11) + tmp13) + tmp15) + tmp17))
	this._f_value = true
	return this.value, nil
}

/**
 * One byte group, clearly divided into 7-bit "value" chunk and 1-bit "continuation" flag.
 */
type Varint_Group struct {
	B uint8
	Pos int64
	_io *kaitai.Stream
	_root *Varint
	_parent *Varint
	_f_hasNext bool
	hasNext bool
	_f_value bool
	value int
}
func NewVarint_Group(pos int64) *Varint_Group {
	return &Varint_Group{
		Pos: pos,
	}
}

func (this *Varint_Group) Read(io *kaitai.Stream, parent *Varint, root *Varint) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp19, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.B = tmp19
	return err
}

/**
 * If true, then we have more bytes to read
 */
func (this *Varint_Group) HasNext() (v bool, err error) {
	if (this._f_hasNext) {
		return this.hasNext, nil
	}
	var tmp20 bool;
	if (this.Pos == 0) {
		tmp20 = this.B >= 240
	} else {
		tmp20 = (this.B & 128) != 0
	}
	this.hasNext = bool(tmp20)
	this._f_hasNext = true
	return this.hasNext, nil
}
func (this *Varint_Group) Value() (v int, err error) {
	if (this._f_value) {
		return this.value, nil
	}
	this.value = int((this.B + 0))
	this._f_value = true
	return this.value, nil
}
